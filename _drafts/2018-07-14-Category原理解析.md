# 目录
[TOC]


# 前言
> 在 *iOS* 开发中，使用的编程语言主要是 **Objective-C**。这一种编程语言虽然是 *C/C++* 的扩展，但是得益于 **Runtime** 的机制，使得 *Objective-C* 比 *C/C++* 更加具备可控性。实际上说 *Objective-C* 是一门可编译的**动态**编程语言，*C/C++* 则是一门**静态**编程语言。
> 在 *Objective-C* 编程语言的 *Runtime* 机制里，每一个 *class* 都是以 *Struct* 的形式存在。这边文章主要是讨论 **Category** 的本质以及运行过程。本文将会结合`官方Runtime`的源码进行解析，这里Xcode可编译的[**源码**](https://github.com/RetVal/objc-runtime)已经放到 github 上了。


# 预知知识
阐述 *Category* 之前，就必须需要预先了解 **Class** 的的本质以及运行时，毕竟 *Category* 是依赖于 *Class* 而存在。不过本文只对 *Class* 作必要的简述，毕竟本文主要是为了阐述 *Category* 的原理。接下来这一节本文会通过以下几个方面了解 *Class*。

## Class 的本质
本文讲述什么是 *Class*，并不是从概念上说这个问题，而是针对 *Objective-C* 这门编程语言而言，在 *C/C++* 是怎么利用 *Runtime* 进行封装，让 *Objective-C* 具有动态性。这里就为了能够解释清楚 *Category*，讲述有关 *Class* 的两个 Struct 分别是 **objc_object** 和 **objc_class**。这些相关代码可以在 `runtime.h` 头文件中找到。

### objc_object 实例对象
如下代码，创建的实例对象，其实是 *objc_object* 结构体。**Runtime** 会去通过结构体里的 `isa` 指针找到对应的 *Class*。
```c++
//实例对象
struct objc_object {
    //指向当前类结构体（objc_class）
    Class isa  OBJC_ISA_AVAILABILITY;
};
```

### objc_class 类
类结构体（*objc_class*）的作用就是实例对象（*objc_object*）调用的实例方法和实例属性都会在这里能够找得到。如下就是类结构体（*objc_class*）的代码结构：
```c++
//类
struct objc_class {
    //指向元类（MetaClass），类型也是 objc_class（主要存放对应的类属性和方法）
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    //指向父类（objc_class）
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    //类名
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    //版本号
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    //实例对象大小
    long instance_size                                       OBJC2_UNAVAILABLE;
    //变量列表(Category不支持添加变量)
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
    //方法列表（指针的指针）
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
    //方法缓存列表（调用过的方法会缓存起来方便下次快速调用）
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    //遵守的协议列表
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;
```

以上类结构体（**objc_class**）中，需要关注的是变量列表`objc_ivar_list`和方法列表`objc_method_list`。

首先，变量列表`objc_ivar_list`的代码结构如下：
```c++
//变量列表结构体
struct objc_ivar_list {
    //变量属性数量
    int ivar_count                                           OBJC2_UNAVAILABLE;
#ifdef __LP64__
    //列表所需空间
    int space                                                OBJC2_UNAVAILABLE;
#endif
    /* variable length structure */
    // 可变长度结构体，用于存储变量数组
    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;
}

//变量
struct objc_ivar {
    //变量名
    char * _Nullable ivar_name                               OBJC2_UNAVAILABLE;
    //变量类型
    char * _Nullable ivar_type                               OBJC2_UNAVAILABLE;
    //变量存储偏移量
    int ivar_offset                                          OBJC2_UNAVAILABLE;
#ifdef __LP64__
    //所需空间
    int space                                                OBJC2_UNAVAILABLE;
#endif
}
```

### Meta Class 元类
objc_class（类）里的 `isa` 指针指向的是 Meta Class（元类），而 Meta Class 其实本质上也是对应的 `objc_class` 结构体。不过 Meta Class 存储的属性和方法都是类方法和类成员属性。每个 Class 的 Meta Class 中的 `isa` 指针会直接指向 `NSObject` 的 Meta Class。

## Class 的运行时
*Objective-C* 对象在编译的时候回先转化为中间语言 **IR** 编程语言，然后会进行代码优化。最后一步，代码优化完成之后会编译成二进制代码执行。另一方面，**二进制兼容**涉及到另外一个 **Non Fragile ivars** 机制。本文不再做介绍，参考文档有详细介绍。

接下来，就简单说明一下 *Objective-C* 对象在运行时的内存存储类型和指向。详情看以下图片：

![Class 运行时](https://alpics-1251916310.file.myqcloud.com/article/2018-07-22-1628088a3e4f0167-2.png)

如上图可知，*Objective-C* 的对象对应的结构体最终都会指向根类 `NSObject`。调用的方法和属性都会在结构体里面相应的表里去找。**方法列表**可以认为是以 `SEL` 为 *Key*，`IMP`为 *Value* 的 HASH 表。

# Category 的基本使用


# Category 与 Extension 的区别


# Category 的本质


# Category 的运行时

# Category 不能添加成员变量的原因

# 常见的使用场景


# 使用注意事项


# 总结


# 参考文档
- [**Apple 官方文档**](https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1)

- [**结合 category 工作原理分析 OC 2.0 中的 runtime**](https://toutiao.io/posts/540138/app_preview)

- [**Objective-C Category 的实现原理**](http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/)

- [**Objective-C的runtime原理**](http://ibloodline.com/articles/2015/11/02/oc-runtime.html)

- [**从源码解读Category实现原理**](https://juejin.im/post/5a9d14856fb9a028e52d5568)

- [**iOS底层原理总结 - Category的本质**](https://juejin.im/post/5aef0a3b518825670f7bc0f3)

- [**Category为何不能添加成员变量?**](https://www.jianshu.com/p/2d63477c4d46)

- [**深入理解Objective-C：Category**](https://tech.meituan.com/DiveIntoCategory.html)

- [**runtime-分类为什么不生成setter和getter**](http://www.cocoachina.com/ios/20170322/18938.html)

- [**Objective-C类成员变量深度剖析**](http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html)

- [**Objective-C 深入理解 +load 和 +initialize**](https://www.jianshu.com/p/872447c6dc3f)

- [**iOS Runtime详解**](https://juejin.im/post/5ac0a6116fb9a028de44d717)