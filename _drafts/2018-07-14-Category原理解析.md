# 目录
[TOC]


# 前言
> 在 *iOS* 开发中，使用的编程语言主要是 **Objective-C**。这一种编程语言虽然是 *C/C++* 的扩展，但是得益于 **Runtime** 的机制，使得 *Objective-C* 比 *C/C++* 更加具备可控性。实际上说 *Objective-C* 是一门可编译的**动态**编程语言，*C/C++* 则是一门**静态**编程语言。
> 在 *Objective-C* 编程语言的 *Runtime* 机制里，每一个 *class* 都是以 *Struct* 的形式存在。这边文章主要是讨论 **Category** 的本质以及运行过程。本文将会结合`官方Runtime`的源码进行解析，这里Xcode可编译的[**源码**](https://github.com/RetVal/objc-runtime)已经放到 github 上了。


# 预知知识
阐述 *Category* 之前，就必须需要预先了解 **Class** 的的本质以及运行时，毕竟 *Category* 是依赖于 *Class* 而存在。不过本文只对 *Class* 作必要的简述，毕竟本文主要是为了阐述 *Category* 的原理。接下来这一节本文会通过以下几个方面了解 *Class*。

## Class 的本质
本文讲述什么是 *Class*，并不是从概念上说这个问题，而是针对 *Objective-C* 这门编程语言而言，在 *C/C++* 是怎么利用 *Runtime* 进行封装，让 *Objective-C* 具有动态性。这里就为了能够解释清楚 *Category*，讲述有关 *Class* 的两个 Struct 分别是 **objc_object** 和 **objc_class**。这些相关代码可以在 `runtime.h` 头文件中找到。

### objc_object
如下代码，创建的实例对象，其实是 *objc_object* 结构体。**Runtime** 会去通过结构体里的 `isa` 指针找到对应的 *Class*。
```c++
//实例对象
struct objc_object {
    //指向当前类结构体（objc_class）
    Class isa  OBJC_ISA_AVAILABILITY;
};
```

### objc_class
类结构体（*objc_class*）的作用就是实例对象（*objc_object*）调用的实例方法和实例属性都会在这里能够找得到。如下就是类结构体（*objc_class*）的代码结构：
```c++
//类
struct objc_class {
    //指向元类（MetaClass），类型也是 objc_class（主要存放对应的类属性和方法）
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    //指向父类（objc_class）
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    //类名
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    //版本号
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    //实例对象大小
    long instance_size                                       OBJC2_UNAVAILABLE;
    //变量列表(Category不支持添加变量)
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
    //方法列表（指针的指针）
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
    //方法缓存列表（调用过的方法会缓存起来方便下次快速调用）
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    //遵守的协议列表
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;
```

以上类结构体（**objc_class**）中，需要关注的是变量列表`objc_ivar_list`和方法列表`objc_method_list`。

首先，变量列表`objc_ivar_list`的代码结构如下：
```c++
//变量列表结构体
struct objc_ivar_list {
    //变量属性数量
    int ivar_count                                           OBJC2_UNAVAILABLE;
#ifdef __LP64__
    //列表所需空间
    int space                                                OBJC2_UNAVAILABLE;
#endif
    /* variable length structure */
    
    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;
}

//变量
struct objc_ivar {
    char * _Nullable ivar_name                               OBJC2_UNAVAILABLE;
    char * _Nullable ivar_type                               OBJC2_UNAVAILABLE;
    int ivar_offset                                          OBJC2_UNAVAILABLE;
#ifdef __LP64__
    int space                                                OBJC2_UNAVAILABLE;
#endif
}
```


## Class 的运行时



# Category 的基本使用


# Category 与 Extension 的区别


# Category 的本质


# Category 的运行时


# 常见的使用场景


# 使用注意事项


# 总结


# 参考文档
[**Apple 官方文档**](https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1)

[**结合 category 工作原理分析 OC 2.0 中的 runtime**](https://toutiao.io/posts/540138/app_preview)

[**Objective-C Category 的实现原理**](http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/)

[Objective-C的runtime原理](http://ibloodline.com/articles/2015/11/02/oc-runtime.html)

[从源码解读Category实现原理](https://juejin.im/post/5a9d14856fb9a028e52d5568)

[iOS底层原理总结 - Category的本质](https://juejin.im/post/5aef0a3b518825670f7bc0f3)