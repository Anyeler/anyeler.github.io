# 目录
[TOC]


# 前言
> 在 *iOS* 开发中，使用的编程语言主要是 **Objective-C**。这一种编程语言虽然是 *C/C++* 的扩展，但是得益于 **Runtime** 的机制，使得 *Objective-C* 比 *C/C++* 更加具备可控性。实际上说 *Objective-C* 是一门可编译的**动态**编程语言，*C/C++* 则是一门**静态**编程语言。
> 在 *Objective-C* 编程语言的 *Runtime* 机制里，每一个 *class* 都是以 *Struct* 的形式存在。这边文章主要是讨论 **Category** 的本质以及运行过程。本文将会结合`官方Runtime`的源码进行解析，这里Xcode可编译的[**源码**](https://github.com/RetVal/objc-runtime)已经放到 github 上了。由于 **Apple** 和 **GNU** 公司一直在维护两个不一样的版本。随着发展，代码也会相应的有所变化，目前源代码是基于 **objc runtime 723** 版本进行分析。


# 预知知识
阐述 *Category* 之前，就必须需要预先了解 **Class** 的的本质以及运行时，毕竟 *Category* 是依赖于 *Class* 而存在。不过本文只对 *Class* 作必要的简述，毕竟本文主要是为了阐述 *Category* 的原理。接下来这一节本文会通过以下几个方面了解 *Class*。

## Class 的本质
本文讲述什么是 *Class*，并不是从概念上说这个问题，而是针对 *Objective-C* 这门编程语言而言，在 *C/C++* 是怎么利用 *Runtime* 进行封装，让 *Objective-C* 具有动态性。这里就为了能够解释清楚 *Category*，讲述有关 *Class* 的两个 Struct 分别是 **objc_object** 和 **objc_class**。这些相关代码可以在 `runtime.h` 头文件中找到。

### objc_object 实例对象
如下代码，创建的实例对象，其实是 *objc_object* 结构体。**Runtime** 会去通过结构体里的 `isa` 指针找到对应的 *Class*。
```c++
//实例对象
struct objc_object {
    //指向当前类结构体（objc_class）
    Class isa  OBJC_ISA_AVAILABILITY;
};
```

### objc_class 类
类结构体（*objc_class*）的作用就是实例对象（*objc_object*）调用的实例方法和实例属性都会在这里能够找得到。如下就是类结构体（*objc_class*）的代码结构：
```c++
//类
struct objc_class {
    //指向元类（MetaClass），类型也是 objc_class（主要存放对应的类属性和方法）
    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    //指向父类（objc_class）
    Class _Nullable super_class                              OBJC2_UNAVAILABLE;
    //类名
    const char * _Nonnull name                               OBJC2_UNAVAILABLE;
    //版本号
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    //实例对象大小
    long instance_size                                       OBJC2_UNAVAILABLE;
    //变量列表(Category不支持添加变量)
    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;
    //方法列表（指针的指针）
    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;
    //方法缓存列表（调用过的方法会缓存起来方便下次快速调用）
    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;
    //遵守的协议列表
    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;
```

以上类结构体（**objc_class**）中，需要关注的是变量列表`objc_ivar_list`和方法列表`objc_method_list`。

首先，变量列表`objc_ivar_list`的代码结构如下：
```c++
//变量列表结构体
struct objc_ivar_list {
    //变量属性数量
    int ivar_count                                           OBJC2_UNAVAILABLE;
#ifdef __LP64__
    //列表所需空间
    int space                                                OBJC2_UNAVAILABLE;
#endif
    /* variable length structure */
    // 可变长度结构体，用于存储变量数组
    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;
}

//变量
struct objc_ivar {
    //变量名
    char * _Nullable ivar_name                               OBJC2_UNAVAILABLE;
    //变量类型
    char * _Nullable ivar_type                               OBJC2_UNAVAILABLE;
    //变量存储偏移量
    int ivar_offset                                          OBJC2_UNAVAILABLE;
#ifdef __LP64__
    //所需空间
    int space                                                OBJC2_UNAVAILABLE;
#endif
}
```

### Meta Class 元类
objc_class（类）里的 `isa` 指针指向的是 Meta Class（元类），而 Meta Class 其实本质上也是对应的 `objc_class` 结构体。不过 Meta Class 存储的属性和方法都是类方法和类成员属性。每个 Class 的 Meta Class 中的 `isa` 指针会直接指向 `NSObject` 的 Meta Class。

## Class 的运行时
*Objective-C* 对象在编译的时候回先转化为中间语言 **IR** 编程语言，然后会进行代码优化。最后一步，代码优化完成之后会编译成二进制代码执行。另一方面，**二进制兼容**涉及到另外一个 **Non Fragile ivars** 机制。本文不再做介绍，参考文档有详细介绍。

接下来，就简单说明一下 *Objective-C* 对象在运行时的内存存储类型和指向。详情看以下图片：

![Class 运行时](https://alpics-1251916310.file.myqcloud.com/article/2018-07-22-1628088a3e4f0167-2.png)

如上图可知，*Objective-C* 的对象对应的结构体最终都会指向根类 `NSObject`。调用的方法和属性都会在结构体里面相应的表里去找。**方法列表**可以认为是以 `SEL` 为 *Key*，`IMP`为 *Value* 的 *Hash* 表。

# Category 的基本使用
在 Xcode 中使用 *Category* 很简单，可以在里面**添加方法**和遵守相应的**协议**。当然，也可以重写方法（苹果不建议），或者添加属性（没有成员变量的属性）。基本的使用由以下代码展示：
```objc
@interface NSObject (Log)
// Category 中不能添加成员变量（这样写需要自己实现get&set方法）
@property (nonatomic, copy) NSString *name;

- (void)testLog;

@end

@implementation NSObject (Log)

- (void)testLog {
    NSLog(@"添加方法");
}

#pragma mark - Getter & Setter
const void *kNameKey; //可用这样关联属性的key
- (NSString *)name { //属性的get方法
    //从 AssociationsHashMap 取值，以 @selector(name) 作为 Key
    NSString *kname = objc_getAssociatedObject(self, _cmd);
    return kname;
}

- (void)setName:(NSString *)name { //属性的set方法
    //在 AssociationsHashMap 添加 key-value
    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY);
}

@end
```

以上代码可知，在 *Category* 里添加属性，变量是使用全局的 Hash 表进行管理。具体原因还是因为 *Category* 是在**运行时才进行加载**的，下文会进行详细说明。

# Category 与 Extension 的区别
`Category` 与 `Extension` 从使用代码层面上看是没什么区别。这里在用法上可以说 *Extension* 是 *Category* 的**特例**。不过需要注意的是 *Extension* **只有**声明，**没有**实现。具体可看以下代码：
```objc
@interface NSObject ()
//添加成员属性
@property (nonatomic, assign) NSInteger age;
//添加方法声明
- (void)agePerson;

@end
```

以上代码，声明了属性和方法。不过注意的是这里的属性是有**成员变量**的。而不是需要存储全局的 Hash 表中。其实本质上原因是 `Extension` 在**编译时期**就加载到类中，而 `Category` 却是在**运行时期**才加载到 **Class 结构体**中。

# Category 的本质
*Category* 的本质主要分为**编译时期**和**运行时期**两个阶段分别阐述。首先，需要知道的是编译时期的 *Category* 并不会把其内容编译进 *Class* 中，只有在运行时期 *Class* 加载完之后，才会添加到已加载在内存中的 *Class* 中。
首先，先查看 `objc-runtime-new.h` 文件中的 *Category* 结构体，代码如下：

```c++
// 分类结构体
struct category_t {
    // 分类名称
    const char *name;
    // 类型
    classref_t cls;
    // 实例方法列表
    struct method_list_t *instanceMethods;
    // 类方法列表
    struct method_list_t *classMethods;
    // 遵守的协议列表
    struct protocol_list_t *protocols;
    // 实例成员属性列表
    struct property_list_t *instanceProperties;
    // Fields below this point are not always present on disk.
    // 类成员属性列表
    struct property_list_t *_classProperties;
    // 用于返回方法列表
    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) return classMethods;
        else return instanceMethods;
    }
    // 用于返回属性列表
    property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);
};
```

如上代码可知，*Category* 可以向 *Class* 中添加**实例方法**、**类方法**、**遵守的协议**以及**成员属性**。不过，需要注意的是这里说的是属性不是成员变量，*Category* 是不可以添加成员变量的。

![方法交换](https://alpics-1251916310.file.myqcloud.com/article/2018-07-23-1628088a3e28be28.png)

# Category 的运行时

```c++
/***********************************************************************
* _objc_init
* Bootstrap initialization. Registers our image notifier with dyld.
* Called by libSystem BEFORE library initialization time
**********************************************************************/

void _objc_init(void)
{
    static bool initialized = false;
    if (initialized) return;
    initialized = true;
    
    // fixme defer initialization until an objc-using image is found?
    environ_init();
    tls_init();
    static_init();
    lock_init();
    exception_init();

    _dyld_objc_notify_register(&map_images, load_images, unmap_image);
}
```

在 App 启动加载镜像文件时，会在 `_read_images` 函数间接调用到 attachCategories 函数，完成向类中添加 Category 的工作。原理就是向 `class_rw_t` 中的 `method_array_t`, `property_array_t`, `protocol_array_t` 数组中分别添加 `method_list_t`, `property_list_t`, `protocol_list_t` 指针。

```c++
/***********************************************************************
* remethodizeClass
* Attach outstanding categories to an existing class.
* Fixes up cls's method list, protocol list, and property list.
* Updates method caches for cls and its subclasses.
* Locking: runtimeLock must be held by the caller
**********************************************************************/
static void remethodizeClass(Class cls)
{
    category_list *cats;
    bool isMeta;

    runtimeLock.assertWriting();

    isMeta = cls->isMetaClass();

    // Re-methodizing: check for more categories
    if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) {
        if (PrintConnecting) {
            _objc_inform("CLASS: attaching categories to class '%s' %s", 
                         cls->nameForLogging(), isMeta ? "(meta)" : "");
        }
        
        attachCategories(cls, cats, true /*flush caches*/);        
        free(cats);
    }
}
```

在调用 `attachCategories` 函数之前，会先使用 `unattachedCategoriesForClass` 函数获取类中还未添加的类别列表。这个列表类型为 `locstamped_category_list_t`，它封装了 `category_t` 以及对应的 `header_info`。`header_info` 存储了实体在镜像中的加载和初始化状态，以及一些偏移量，在加载 Mach-O 文件相关函数中经常用到。

```c++
// Attach method lists and properties and protocols from categories to a class.
// Assumes the categories in cats are all loaded and sorted by load order, 
// oldest categories first.
// Class 加载完之后会加载分类列表并添加到类结构体中去
static void 
attachCategories(Class cls, category_list *cats, bool flush_caches)
{
    if (!cats) return; // 判断有没有分类列表
    // 打印需要替换的方法
    if (PrintReplacedMethods) printReplacements(cls, cats);
    // 是否为元类
    bool isMeta = cls->isMetaClass();

    // fixme rearrange to remove these intermediate allocations
    // 分配相应的实例/类方法、属性、协议列表指针，相当于二维链表，一个分类对应一个一维链表
    method_list_t **mlists = (method_list_t **)
        malloc(cats->count * sizeof(*mlists));
    property_list_t **proplists = (property_list_t **)
        malloc(cats->count * sizeof(*proplists));
    protocol_list_t **protolists = (protocol_list_t **)
        malloc(cats->count * sizeof(*protolists));

    // Count backwards through cats to get newest categories first
    int mcount = 0;
    int propcount = 0;
    int protocount = 0;
    int i = cats->count;
    bool fromBundle = NO;
    // 循环分类列表
    while (i--) {
        // 取出第 i 个分类
        auto& entry = cats->list[i];
        // 从分类里取出对应的实例/类方法表
        method_list_t *mlist = entry.cat->methodsForMeta(isMeta);
        if (mlist) {
            // 将实例/类方法列表赋值到对应的二维链表中
            mlists[mcount++] = mlist;
            fromBundle |= entry.hi->isBundle();
        }
        // 从分类里取出对应的实例/类属性列表，并加到对应的二维链表中
        property_list_t *proplist = 
            entry.cat->propertiesForMeta(isMeta, entry.hi);
        if (proplist) {
            proplists[propcount++] = proplist;
        }
        // 从分类里取出遵守的协议列表，并加到对应的二维链表中
        protocol_list_t *protolist = entry.cat->protocols;
        if (protolist) {
            protolists[protocount++] = protolist;
        }
    }
    
    // 遍历完分类后，取出类/元类的内存数据域（堆区）
    auto rw = cls->data();
    // 准备方法列表：加锁扫描方法列表，将新方法放在每一个分类的方法前面（对每个分类方法进行排序）
    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);
    // 添加方法到类/元类中
    rw->methods.attachLists(mlists, mcount);
    // 释放二维方法列表
    free(mlists);
    // 刷新方法缓存
    if (flush_caches  &&  mcount > 0) flushCaches(cls);
    // 添加属性到类/元类中
    rw->properties.attachLists(proplists, propcount);
    // 释放二维属性列表
    free(proplists);
    // 添加遵守的协议到类/元类中
    rw->protocols.attachLists(protolists, protocount);
    // 释放二维协议列表
    free(protolists);
}
```

```c++
void attachLists(List* const * addedLists, uint32_t addedCount) {
    if (addedCount == 0) return;

    if (hasArray()) {
        // many lists -> many lists
        uint32_t oldCount = array()->count;
        uint32_t newCount = oldCount + addedCount;
        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));
        array()->count = newCount;
        memmove(array()->lists + addedCount, array()->lists, 
                oldCount * sizeof(array()->lists[0]));
        memcpy(array()->lists, addedLists, 
               addedCount * sizeof(array()->lists[0]));
    }
    else if (!list  &&  addedCount == 1) {
        // 0 lists -> 1 list
        list = addedLists[0];
    } 
    else {
        // 1 list -> many lists
        List* oldList = list;
        uint32_t oldCount = oldList ? 1 : 0;
        uint32_t newCount = oldCount + addedCount;
        setArray((array_t *)malloc(array_t::byteSize(newCount)));
        array()->count = newCount;
        if (oldList) array()->lists[addedCount] = oldList;
        memcpy(array()->lists, addedLists, 
               addedCount * sizeof(array()->lists[0]));
    }
}
```

# Category 不能添加成员变量的原因
由于一个结构体都是**连续分配的内存空间**，所以，这里就涉及到了一个问题为什么在运行时， *Category* 不能添加成员变量，因为这样需要根据需要调整整个结构体的内存空间，影响性能。

# 常见的使用场景


# 使用注意事项


# 总结


# 参考文档
- [**Apple 官方文档**](https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1)

- [**结合 category 工作原理分析 OC 2.0 中的 runtime**](https://toutiao.io/posts/540138/app_preview)

- [**Objective-C Category 的实现原理**](http://blog.leichunfeng.com/blog/2015/05/18/objective-c-category-implementation-principle/)

- [**Objective-C的runtime原理**](http://ibloodline.com/articles/2015/11/02/oc-runtime.html)

- [**从源码解读Category实现原理**](https://juejin.im/post/5a9d14856fb9a028e52d5568)

- [**iOS底层原理总结 - Category的本质**](https://juejin.im/post/5aef0a3b518825670f7bc0f3)

- [**Category为何不能添加成员变量?**](https://www.jianshu.com/p/2d63477c4d46)

- [**深入理解Objective-C：Category**](https://tech.meituan.com/DiveIntoCategory.html)

- [**runtime-分类为什么不生成setter和getter**](http://www.cocoachina.com/ios/20170322/18938.html)

- [**Objective-C类成员变量深度剖析**](http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html)

- [**Objective-C 深入理解 +load 和 +initialize**](https://www.jianshu.com/p/872447c6dc3f)

- [**iOS Runtime详解**](https://juejin.im/post/5ac0a6116fb9a028de44d717)

- [**iOS中的Category详解**](https://www.jianshu.com/p/f673206c5abc)

- [**玉令天下的博客 Objective-C Runtime**](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/#class-rw-t)